# P5 课上

## t1

一个十分奇怪的运算，好像是根据 grf[rt] 的大小和二进制下一的数量对 grf[rs] 进行取反和右移

主要就是改 ALU 就行了，需要仔细看清楚题目

如果写法比较简单的话可能需要注意一下 verilog 中 fuction 的写法

## t2 （L9）

> 一个有趣的事情，我把 t2 和 t3 搞反了，做完才反应过来自己做的 t3 太简单（
>
> 这里是按照正常是顺序的 P3

一个叫做 `bao` 的指令

在 ALU 中按照指示添加对于 A1，A2 相加是否溢出的布尔运算，其余操作与 beq 相同

## t3 （L6)

也是一个奇怪的指令，似乎是判断 grf[rt] 二进制下 01 数量是否相等 （即 1 为 16 个），并由此修改 DM 的输入

具体改法也相当奇怪。。

这里用了之前了解到的一种端口选择方法 mem[x -: 8] ，即从 x 开始连续 8 位，应该可以帮助简化一定代码量

----

$$
fin
$$